window.addEventListener("load",function() {

    /* temporarily we will load on the front page so that we don't need to login with twitter */
    //  if ($('#heart-core').length !== 1) return;

    var Q = window.Q = Quintus({ imagePath: "/", dataPath: "/", development: true })
    .include("Sprites, Scenes, Input, 2D, UI, Anim")
    .setup("heart-core", { width: 14*32, height: 9*32 });

    Q.debounce = function(func, wait, immediate) {
        var timeout, args, context, timestamp, result;
        return function() {
            context = this;
            args = arguments;
            timestamp = new Date();
            var later = function() {
                var last = (new Date()) - timestamp;
                if (last < wait) {
                    timeout = setTimeout(later, wait - last);
                } else {
                    timeout = null;
                    if (!immediate) result = func.apply(context, args);
                }
            };
            var callNow = immediate && !timeout;
            if (!timeout) {
                timeout = setTimeout(later, wait);
            }
            if (callNow) result = func.apply(context, args);
            return result;
        };
    };


    Q.animations('hand', {
        move_right: { frames: [7,6,5,4,3,2,1], rate: 1/15},
        move_left: { frames: [19,18,17,16,15], rate:1/15 },
        move_up: { frames: [165,185], rate: 1/15 },
        move_down: { frames: [186, 187], rate: 1/15 }
    });

    Q.getActiveStage = function () {
        return Q.stages[0];
    };

    var SPRITE_PLAYER = 1;
    var SPRITE_TILES  = 2;
    var SPRITE_ENEMY  = 4;
    var SPRITE_DOT    = 8;

    var ROOM_WIDTH  = 448;
    var ROOM_HEIGHT = 288;

    var LEFT  = [-1,  0];
    var RIGHT = [ 1,  0];
    var UP    = [ 0, -1];
    var DOWN  = [ 0,  1];

    Q.input.keyboardControls();
    Q.input.joypadControls();

    Q.gravityY = 0;
    Q.gravityX = 0;

    Q.rooms = {
        dimensions: { w: 2, h:  2 },
        items: ['<%= asset_path("room_0.tmx") %>', '<%= asset_path("room_1.tmx") %>', '<%= asset_path("room_2.tmx") %>', '<%= asset_path("room_3.tmx") %>']
    };

    Q.state.damagePlayer = function (amount) {
        this.set("damage", this.p.damage + amount);
        Q.state.checkPlayerDeath();
    };

    Q.state.checkPlayerDeath = function () {
        console.log("Checking player death...");
        if (this.p.hp > this.p.damage) return;

        /* player is dead */
        Q.stageScene("endGame",1, { label: "Game Over" }); 
        collision.obj.destroy();
    };

    /* this is a little weird: the room list is an array with
     * a width and height specified. If the player goes left,
     * or up, I can determine the next spot in the array to
     * use. There are edge cases, such as the player going "left"
     * when they are already at the left-most room. In this
     * case my solution won't work, because left would wrap them
     * around the world. However, I can ignore those cases, since
     * the left-most room will not have an exit left option.
     * (NOTE: it also makes for a cool glitch later) */
    Q.state.offsetForDirection = function (direction) {
        /* TODO name this variable */
        var what_to_call_this = [1, Q.rooms.dimensions.w];

        for (i = 0; i < 2; i++) {
            what_to_call_this[i] *= direction[i];
        }

        return (what_to_call_this[0] !== 0)? what_to_call_this[0] : what_to_call_this[1];
    };

    Q.state.nextRoom = function (direction) {

        var offset = this.offsetForDirection(direction);
        var room_file = Q.rooms.items[this.p.room + offset];

        Q.state.set("room", this.p.room + offset); // update the current room

        var room_origin = {
            x: ROOM_WIDTH * direction[0],
            y: ROOM_HEIGHT * direction[1]
        }

        /* going from room 2 to room 3 we do x: 224, y: 0 */
        return new Q.Room({
            dataAsset: room_file,
            layerIndex: 0,
            sheet: 'hand',
            tileW: 32,
            tileH: 32,
            x: room_origin.x / 2,
            y: room_origin.y / 2,
            type: SPRITE_TILES
        });
    };


    Q.TileLayer.extend("Room", {
        init: function (p) {
            this._super(p);

            this.add("tween");
        }
    });

    Q.Sprite.extend("Heart", {
        init: function (p) {
            p.asset  = '<%= asset_path("full-heart.png") %>';
            p.damage = 0;

            this._super(p);
        },

        giveHeart: function () {
            console.log("yo");
        },

        breakHeart: function () {
            if (this.p.asset === '<%= asset_path("broken-heart.png") %>') return;

            this.p.damage += 1;
            this.p.asset = (this.p.damage === 1)? '<%= asset_path("half-heart.png") %>' : '<%= asset_path("broken-heart.png") %>';

            return this;
        }
    });

    Q.Sprite.extend("Monster", {
        init: function (p) {
            p.sheet = "hand";
            p.frame = 37;
            this._super(p);
            this.add("2d");

            this.on("bump", this.melee);
        },

        melee: function (col) {
            if (col.obj.isA("Player")) {
                Q.state.damagePlayer();
            }
        }
    });

    Q.Sprite.extend("Player", {
        init: function(p) {
            p.z = 1; // player on TOP!

            this._super(p,{
                sheet:"hand",
                frame: 186,
                type: SPRITE_PLAYER,
                collisionMask: SPRITE_TILES | SPRITE_ENEMY | SPRITE_DOT
            });

            this.add("2d, stepControls, tween, animation, heartAction");
            this.on("step", this.checkBounds);

            this.heartAction = Q.debounce(this._heartAction, 500);
        },

        _heartAction: function () {
            console.log("heartAction");

            $("[data-toggle=modal]").trigger("click.bs.modal.data-api");
        },

        /* if the player leaves the scene, we stage the next scene */
        checkBounds: function () {
            var rel_x = this.p.x;
            var rel_y = this.p.y;

            $('#player_x').text(rel_x);
            $('#player_y').text(rel_y);
            var out_x = (0 < rel_x && rel_x < ROOM_WIDTH) ? false : true;
            var out_y = (0 < rel_y && rel_y < ROOM_HEIGHT) ? false : true;
            var exiting = out_x || out_y;

            Q.state.set("exiting", exiting);
        },

        step: function(dt) {
            if(this.p.vx > 0) {
                this.play("move_right");
            } else if(this.p.vx < 0) {
                this.play("move_left");
            } else if (this.p.vy > 0) {
                this.play("move_down");
            } else if (this.p.vy < 0) {
                this.play("move_up");
            } else {
                // no animation
            }
        }
    });

    Q.scene("heart_bar", function(stage) {
        stage.p = {};

        var hearts = [];
        for (i = 0; i < Q.state.get("hp"); i++) {
            offset = 32 * i + 20;
            hearts.push(new Q.Heart({
                x: ROOM_WIDTH - 36 - (32 * i),
                y: 36
            }));

            heart = stage.insert(hearts[i]);
            heart.on("click", heart.giveHeart);
        };

        stage.p.hearts = hearts;
        /* when the player loses hearts we 
         * do this */
        this.updateHearts = function (hp) {
            var length = stage.p.hearts.length;

            for (; length > hp; length--) {
                var heart = stage.p.hearts.pop();

                stage.remove(heart);
            }

            Q.state.checkPlayerDeath();
        };

        Q.state.on("change.hp", this.updateHearts);
    });

    Q.scene("endGame",function(stage) {
        alert("game over");
        window.location = "";
    });

    Q.scene("overworld",function(stage) {
        var starting_x = 4*32 + 16;
        var starting_y = 5*32 + 16;

        Q.state.reset({
            // the universal coords of the current room
            room: 2,
            room_x: 0,
            room_y: 0,
            hp: $('[data-hp]').data('hp'),
            damage: 0,

            // whether the game state thinks the player is "leaving"
            exiting: false
        });

        stage.p = {};
        stage.p.rooms = [];

        var room       = new Q.Room({ dataAsset: Q.rooms.items[Q.state.get("room")], layerIndex: 0, sheet: 'hand', tileW: 32, tileH: 32, type: SPRITE_TILES });
        var background = new Q.Room({ dataAsset: '<%= asset_path("background.tmx") %>', layerIndex: 0, sheet: 'hand', tileW: 32, tileH: 32, type: Q.SPRITE_NONE });
        stage.insert(background);
        stage.collisionLayer(room);
        stage.p.rooms[Q.state.get("room")] = room;

        var player = stage.insert(new Q.Player({ x: starting_x, y: starting_y }));

        stage.getRoom = function (i) {
            return this.p.rooms[i];
        };

        stage.on("click", function () { console.log("wat"); })
        player.on("click", function () { console.log("player"); })

        this.zeldaSlide = function () {
            if (Q.state.get("exiting") === false) return false;

            var player = Q('Player').first();
            var p = player.p;

            var rel_x = p.x;
            var rel_y = p.y;

            /* we know that the player is exiting, we have but
             * to determine the direction */
            var direction =     (rel_x < 0)? LEFT           :
                                (rel_y < 0)? UP             :
                                (rel_x > ROOM_WIDTH)? RIGHT : DOWN;

            var stage = Q.getActiveStage();
            var current_room = stage.getRoom(Q.state.get("room"));
            var new_room = Q.state.nextRoom(direction);

            /* set rel_x and rel_y so that the relevant one is near zero */
            if (direction[0] !== 0) {
                rel_x += (direction[0] < 0)? ROOM_WIDTH  : -ROOM_WIDTH;

            } else {
                rel_y += (direction[1] < 0)? ROOM_HEIGHT : -ROOM_HEIGHT;
            }

            /* we slide room 2 to x: -224, y: 224 and room 3 to x: 0, y: 0 */

            stage.collisionLayer(new_room);
            stage.p.rooms[Q.state.get("room")] = new_room;
            current_room.animate({ x: -(direction[0]) * (ROOM_WIDTH / 2), y: -(direction[1]) * (ROOM_HEIGHT / 2) }, { callback: function () {
                stage.remove(current_room); // I sort of have to use an anonymous function here
            }});

            new_room.animate({ x: 0, y:0 });
            player.animate({ x: rel_x, y: rel_y });
        };

        /* later, add this to a component called "zeldaSlide" */
        Q.state.on("change.exiting", this.zeldaSlide);
    });

    console.log("<%= asset_path("full-heart.png") %>, <%= asset_path("half-heart.png") %>, <%= asset_path("broken-heart.png") %>, <%= asset_path("background.tmx") %>, <%= asset_path("zelda_hand_tiles.png") %>, <%= asset_path("zelda_hand_test.tmx") %>, <%= asset_path("room_0.tmx") %>, <%= asset_path("room_1.tmx") %>, <%= asset_path("room_2.tmx") %>, <%= asset_path("room_3.tmx") %>");
    Q.load("<%= asset_path("full-heart.png") %>, <%= asset_path("half-heart.png") %>, <%= asset_path("broken-heart.png") %>, <%= asset_path("background.tmx") %>, <%= asset_path("zelda_hand_tiles.png") %>, <%= asset_path("zelda_hand_test.tmx") %>, <%= asset_path("room_0.tmx") %>, <%= asset_path("room_1.tmx") %>, <%= asset_path("room_2.tmx") %>, <%= asset_path("room_3.tmx") %>", function() {
        Q.sheet("hand","<%= asset_path('zelda_hand_tiles.png') %>", { tilew: 32, tileh: 32});
        Q.stageScene("overworld", 0, { sort: function (a, b) {
            return a.p.z > b.p.z;
        }});
        Q.stageScene("heart_bar", 1);

        /* the player could already be dead... */
        Q.state.checkPlayerDeath();
    });

    Q.component("heartAction", {

        added: function() {
            var p = this.entity.p;

            this.entity.on("step",this,"step");
        },

        step: function(dt) {
            var p = this.entity.p;

            if(Q.inputs['action']) {
                this.entity.heartAction();
            }
        }
    });
});

