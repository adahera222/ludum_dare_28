window.addEventListener("load",function() {
    /* temporarily we will load on the front page so that we don't need to login with twitter */
    //  if ($('#heart-core').length !== 1) return;

    // TODO uncomment this in production
    // var Q = window.Q = Quintus({ imagePath: "public/assets/", dataPath: "public/assets/" })
    // OK so in production we may need to just set image path to "/public/" because asset_path
    // generates a string that includes "assets/"
    var Q = window.Q = Quintus({ imagePath: "/assets/", dataPath: "/assets/", development: true })
    .include("Sprites, Scenes, Input, 2D, UI, Anim")
    .setup("heart-core", { width: 14*32, height: 9*32 });

    Q.getActiveStage = function () {
        return Q.stages[0];
    };

    var SPRITE_PLAYER = 1;
    var SPRITE_TILES  = 2;
    var SPRITE_ENEMY  = 4;
    var SPRITE_DOT    = 8;

    var ROOM_WIDTH  = 448;
    var ROOM_HEIGHT = 288;

    var LEFT  = [-1,  0];
    var RIGHT = [ 1,  0];
    var UP    = [ 0, -1];
    var DOWN  = [ 0,  1];

    Q.input.keyboardControls();
    Q.input.joypadControls();

    Q.gravityY = 0;
    Q.gravityX = 0;

    Q.rooms = {
        dimensions: { w: 2, h:  2 },
        items: ["room_0.tmx", "room_1.tmx", "room_2.tmx", "room_3.tmx"]
    };

    Q.state.damagePlayer = function (amount) {
        this.set("hp", this.p.hp - amount);
    };

    /* this is a little weird: the room list is an array with
     * a width and height specified. If the player goes left,
     * or up, I can determine the next spot in the array to
     * use. There are edge cases, such as the player going "left"
     * when they are already at the left-most room. In this
     * case my solution won't work, because left would wrap them
     * around the world. However, I can ignore those cases, since
     * the left-most room will not have an exit left option.
     * (NOTE: it also makes for a cool glitch later) */
    Q.state.offsetForDirection = function (direction) {
        /* TODO name this variable */
        var what_to_call_this = [1, Q.rooms.dimensions.w];

        for (i = 0; i < 2; i++) {
            what_to_call_this[i] *= direction[i];
        }

        return (what_to_call_this[0] !== 0)? what_to_call_this[0] : what_to_call_this[1];
    };

    Q.state.nextRoom = function (direction) {

        var offset = this.offsetForDirection(direction);
        var room_file = Q.rooms.items[this.p.room + offset];

        Q.state.set("room", this.p.room + offset); // update the current room

        var room_origin = {
            x: ROOM_WIDTH * direction[0],
            y: ROOM_HEIGHT * direction[1]
        }

        /* going from room 2 to room 3 we do x: 224, y: 0 */
        return new Q.Room({
            dataAsset: room_file,
            layerIndex: 0,
            sheet: 'hand',
            tileW: 32,
            tileH: 32,
            x: room_origin.x / 2,
            y: room_origin.y / 2,
            type: SPRITE_TILES
        });
    };


    Q.TileLayer.extend("Room", {
        init: function (p) {
            this._super(p);

            this.add("tween");
        }
    });

    Q.Sprite.extend("FullHeart", {
        init: function (p) {
            this._super(p);
        }
    });

    Q.Sprite.extend("Monster", {
        init: function (p) {
            this._super(p);
            this.add("2d");

            this.on("bump", this.melee);
        },

        melee: function (col) {
            if (col.obj.isA("Player")) {
                Q.state.damagePlayer();
            }
        }
    });

    Q.Sprite.extend("Player", {
        init: function(p) {
            p.z = 1; // player on TOP!

            this._super(p,{
                sheet:"player",
                type: SPRITE_PLAYER,
                collisionMask: SPRITE_TILES | SPRITE_ENEMY | SPRITE_DOT
            });

            this.add("2d, stepControls, tween");
            this.on("step", this.checkBounds);
        },

        /* if the player leaves the scene, we stage the next scene */
        checkBounds: function () {
            var rel_x = this.p.x;
            var rel_y = this.p.y;

            $('#player_x').text(rel_x);
            $('#player_y').text(rel_y);
            var out_x = (0 < rel_x && rel_x < ROOM_WIDTH) ? false : true;
            var out_y = (0 < rel_y && rel_y < ROOM_HEIGHT) ? false : true;
            var exiting = out_x || out_y;

            Q.state.set("exiting", exiting);
        }
    });

    Q.scene("heart_bar", function(stage) {

        var hearts = [];
        for (i = 0; i < 1; i++) {
            hearts.push(new Q.FullHeart({
                x: 10,
                y: 10
            }));
            stage.insert(hearts[0]);
        };

        this.updateHearts = function () {
            console.log("updating hearts");
        };

        Q.state.change("hp", this.updateHearts);
    });

    Q.scene("overworld",function(stage) {
        var starting_x = 4*32 + 16;
        var starting_y = 5*32 + 16;

        Q.state.reset({
            // the universal coords of the current room
            room: 2,
            room_x: 0,
            room_y: 0,
            hp: 2,

            // whether the game state thinks the player is "leaving"
            exiting: false
        });

        stage.p = {};
        stage.p.rooms = [];

        var room       = new Q.Room({ dataAsset: Q.rooms.items[Q.state.get("room")], layerIndex: 0, sheet: 'hand', tileW: 32, tileH: 32, type: SPRITE_TILES });
        var background = new Q.Room({ dataAsset: "background.tmx", layerIndex: 0, sheet: 'hand', tileW: 32, tileH: 32, type: Q.SPRITE_NONE });
        stage.insert(background);
        stage.collisionLayer(room);
        stage.p.rooms[Q.state.get("room")] = room;

        var player = stage.insert(new Q.Player({ x: starting_x, y: starting_y }));

        stage.getRoom = function (i) {
            return this.p.rooms[i];
        };

        this.zeldaSlide = function () {
            if (Q.state.get("exiting") === false) return false;

            var player = Q('Player').first();
            var p = player.p;

            var rel_x = p.x;
            var rel_y = p.y;

            /* we know that the player is exiting, we have but
             * to determine the direction */
            var direction =     (rel_x < 0)? LEFT           :
                                (rel_y < 0)? UP             :
                                (rel_x > ROOM_WIDTH)? RIGHT : DOWN;

            var stage = Q.getActiveStage();
            var current_room = stage.getRoom(Q.state.get("room"));
            var new_room = Q.state.nextRoom(direction);

            /* set rel_x and rel_y so that the relevant one is near zero */
            if (direction[0] !== 0) {
                rel_x += (direction[0] < 0)? ROOM_WIDTH  : -ROOM_WIDTH;

            } else {
                rel_y += (direction[1] < 0)? ROOM_HEIGHT : -ROOM_HEIGHT;
            }

            /* we slide room 2 to x: -224, y: 224 and room 3 to x: 0, y: 0 */

            stage.collisionLayer(new_room);
            stage.p.rooms[Q.state.get("room")] = new_room;
            current_room.animate({ x: -(direction[0]) * (ROOM_WIDTH / 2), y: -(direction[1]) * (ROOM_HEIGHT / 2) }, { callback: function () {
                stage.remove(current_room); // I sort of have to use an anonymous function here
            }});

            new_room.animate({ x: 0, y:0 });
            player.animate({ x: rel_x, y: rel_y });
        };

        /* later, add this to a component called "zeldaSlide" */
        Q.state.on("change.exiting", this.zeldaSlide);
    });

    console.log("<%= asset_path("full-heart.png") %>, <%= asset_path("half-heart.png") %>, <%= asset_path("broken-heart.png") %>, <%= asset_path("background.tmx") %>, <%= asset_path("zelda_hand_tiles.png") %>, <%= asset_path("zelda_hand_test.tmx") %>, <%= asset_path("room_0.tmx") %>, <%= asset_path("room_1.tmx") %>, <%= asset_path("room_2.tmx") %>, <%= asset_path("room_3.tmx") %>");
    Q.load("full-heart.png, half-heart.png, broken-heart.png, background.tmx, zelda_hand_tiles.png, zelda_hand_test.tmx, room_0.tmx, room_1.tmx, room_2.tmx, room_3.tmx", function() {
        Q.sheet("hand","zelda_hand_tiles.png", { tilew: 32, tileh: 32});
        Q.stageScene("overworld", 0, { sort: function (a, b) {
            return a.p.z > b.p.z;
        }});
        // Q.stageScene("heart_bar", 0, { sort: function (a, b) {
    });
});

